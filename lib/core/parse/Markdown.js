const toSlug = require('./toSlug.js');

const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';

class Markdown {
  headings(content) {
    const rx = /^(#{1,3})\s+(.*)/;
    return content.split(/\r?\n/)
      .map(line => line.match(rx))
      .filter(match => !!match)
      .map(match => ({
        level: match[1].length,
        caption: match[2],
        slug: toSlug(match[2])
      }));
  }

  levelIndents(level, minLevel) {
    let indents = '';
    for (var i = minLevel; i < level; i++) { indents += '  '; }
    return indents;
  }

  calcTOC(content) {
    const headings = this.headings(content);
    let minLevel = 100; // a max number
    headings.forEach(heading => {
      if (minLevel > heading.level) { minLevel = heading.level; }
    });

    return headings
      .map(heading => (
        this.levelIndents(heading.level, minLevel) + '- ' +
        '[' + heading.caption + ']' +
        '(#' + heading.slug + ')'
      ))
      //.map(heading => `  - [${heading.caption}](#${heading.slug})`)
      .join('\n');
  }

  generateTOC(content) {
    const toc = this.calcTOC(content);
    content = content.replace(TABLE_OF_CONTENTS_TOKEN, toc);
    return content;
  }

  calcLinkMap(metadatas, siteConfig) {
    const linkMap = {};
    Object.keys(metadatas).forEach(id => {
      const metadata = metadatas[id];
      linkMap[metadata.source] =
        siteConfig.baseUrl + metadata.permalink.replace('/next/', '/');
    });
    return linkMap;
  }

  replaceLinksWithFull(content, metadatas, siteConfig) {
    content = this.replaceDocLinksWithFull(content, metadatas, siteConfig);
    content = this.replaceAssetLinksWithFull(content, siteConfig);
    return content;
  }

  replaceDocLinksWithFull(content, metadatas, siteConfig) {
    const linkMap = this.calcLinkMap(metadatas, siteConfig);
    Object.keys(linkMap).forEach(function(key, index) {
      const link = linkMap[key];
      content = content.replace(
        new RegExp('\\]\\((\\./)?' + key, 'g'),
        '](' + link
      );
    });
    return content;
  }

  replaceAssetLinksWithFull(content, siteConfig) {
    content = content.replace(
      /\]\(assets\//g,
      '](' + siteConfig.baseUrl + 'docs/assets/'
    );
    return content;
  }

  extractMetadata(file_content) {
    const { header, content } = this.splitHeader(file_content);
    const metadata = { content: content };
    header.split('\n')
      .forEach(line => {
        const parts = line.split(':');
        const key = parts[0].trim();
        let value = parts.slice(1).join(':').trim();
        try {
          value = JSON.parse(value);
        } catch(e) {}
        metadata[key] = value;
      });
    return metadata;
  }

  splitHeader(content) {
    const lines = content.split(/\r?\n/);
    if (lines[0] !== '---') { return { header: '', content: content }; }

    for (var i = 1; i < lines.length - 1; i++) {
      if (lines[i] === '---') {
        return {
          header: lines.slice(1, i + 1).join('\n'),
          content: lines.slice(i + 1).join('\n'),
        };
      }
    }

    return { header: '', content: content };
  }
}

module.exports = Markdown;
